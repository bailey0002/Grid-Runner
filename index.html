<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>GRID_RUNNER 3D — LIGHT CYCLE</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;touch-action:none;background:#000008;font-family:'Orbitron',sans-serif;color:#0ff}
#app{display:flex;flex-direction:column;height:100%;width:100%}
#viewport{position:relative;flex:1;min-height:0;background:#000}
#viewport canvas{display:block;width:100%!important;height:100%!important}
#hud{position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;pointer-events:none;z-index:10}
.hp{background:rgba(0,5,20,0.82);border:1px solid #0af3;border-radius:4px;padding:5px 10px;font-size:10px;letter-spacing:1.2px;display:flex;gap:12px;align-items:center;text-transform:uppercase}
.st{display:flex;align-items:center;gap:4px}
.sl{color:#0af8;font-size:8px;font-family:'Share Tech Mono',monospace}
.sv{color:#0ff;font-weight:700;font-size:11px;text-shadow:0 0 8px #0ff4}
#pip{position:absolute;bottom:8px;left:8px;width:150px;height:150px;border:1px solid #0af4;border-radius:4px;background:rgba(0,5,15,0.85);z-index:10}
#pip canvas{width:100%;height:100%;border-radius:3px}
#pip-label{position:absolute;top:3px;left:6px;font-size:7px;color:#0af8;letter-spacing:2px;font-family:'Share Tech Mono',monospace}
#messages{position:absolute;top:40px;left:50%;transform:translateX(-50%);pointer-events:none;z-index:10;display:flex;flex-direction:column;gap:3px;align-items:center}
.message{background:rgba(0,5,20,0.9);border:1px solid #0af3;border-radius:3px;padding:4px 14px;font-size:10px;font-family:'Share Tech Mono',monospace;color:#0ff;letter-spacing:1px;text-shadow:0 0 6px #0ff4;animation:msgFade 3s forwards;white-space:nowrap}
@keyframes msgFade{0%{opacity:1}70%{opacity:1}100%{opacity:0;transform:translateY(-10px)}}
#controls{height:150px;min-height:150px;background:linear-gradient(180deg,#000a18 0%,#000510 100%);border-top:1px solid #0af3;display:flex;align-items:center;justify-content:space-between;padding:8px 16px}
.stick-wrap{display:flex;flex-direction:column;align-items:center;gap:3px;flex-shrink:0}
.stick-zone{width:110px;height:110px;position:relative}
.stick-base{position:absolute;inset:0;border:2px solid #0af4;border-radius:50%;background:rgba(0,10,30,0.5)}
.stick-knob{position:absolute;width:42px;height:42px;top:50%;left:50%;transform:translate(-50%,-50%);border:2px solid #0ff;border-radius:50%;background:rgba(0,255,255,0.15);box-shadow:0 0 16px rgba(0,255,255,0.3)}
.stick-knob.thr{border-color:#ff0;background:rgba(255,255,0,0.12);box-shadow:0 0 16px rgba(255,255,0,0.2)}
.stick-knob.active{background:rgba(0,255,255,0.3)}.stick-knob.thr.active{background:rgba(255,255,0,0.3)}
.stick-label{font-size:7px;color:#0af8;letter-spacing:2px;font-family:'Share Tech Mono',monospace}
#ctrl-center{display:flex;flex-direction:column;align-items:center;gap:3px;flex:1}
#speed-display{font-size:30px;font-weight:900;color:#0ff;text-shadow:0 0 12px #0ff4;font-family:'Orbitron',sans-serif}
#speed-label{font-size:7px;color:#0af8;letter-spacing:3px;font-family:'Share Tech Mono',monospace}
#boost-outer{width:110px;height:5px;background:#0a0a20;border:1px solid #0af3;border-radius:3px;overflow:hidden;margin-top:3px}
#boost-bar{height:100%;background:linear-gradient(90deg,#ff0,#f80);border-radius:2px;width:100%}
#floor-ind{font-size:8px;color:#0af;letter-spacing:2px;font-family:'Share Tech Mono',monospace;margin-top:2px}
.overlay{position:absolute;inset:0;z-index:200;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,8,0.92)}
.overlay.hidden{display:none}
.ov-title{font-size:clamp(28px,7vw,48px);font-weight:900;letter-spacing:10px;margin-bottom:6px;text-shadow:0 0 30px currentColor}
.ov-title.cyan{color:#0ff}.ov-title.red{color:#f04}.ov-title.green{color:#0f8}
.ov-sub{font-size:clamp(10px,2vw,13px);letter-spacing:5px;color:#0af;margin-bottom:30px;font-family:'Share Tech Mono',monospace}
.ov-btn{padding:14px 40px;border:2px solid #0ff;border-radius:4px;background:rgba(0,255,255,0.08);color:#0ff;font-family:'Orbitron',sans-serif;font-size:16px;font-weight:700;letter-spacing:5px;cursor:pointer;-webkit-tap-highlight-color:transparent;animation:pulse 1.5s ease-in-out infinite}
.ov-btn:active{background:rgba(0,255,255,0.25)}
.ov-info{margin-top:20px;font-size:9px;color:#0af6;letter-spacing:1.5px;font-family:'Share Tech Mono',monospace;text-align:center;line-height:2.2}
@keyframes pulse{0%,100%{opacity:0.6}50%{opacity:1}}
</style>
</head>
<body>
<div id="app">
<div id="viewport">
  <div id="hud"><div class="hp"><div class="st"><span class="sl">ALIVE</span><span class="sv" id="alive-val"></span></div><div class="st"><span class="sl">ROUND</span><span class="sv" id="round-val"></span></div></div><div class="hp"><div class="st"><span class="sl">WINS</span><span class="sv" id="wins-val"></span></div><div class="st"><span class="sl">SCORE</span><span class="sv" id="score-val"></span></div></div></div>
  <div id="messages"></div>
  <div id="pip"><div id="pip-label">GRID MAP</div><canvas id="minimap" width="150" height="150"></canvas></div>
  <div id="scr-title" class="overlay">
    <div class="ov-title cyan">GRID_RUNNER</div>
    <div class="ov-sub">[ LIGHT CYCLE ARENA ]</div>
    <button class="ov-btn" id="btn-start">▶ ENTER GRID</button>
    <div class="ov-info">LEFT: STEER • RIGHT: THROTTLE<br>TRAILS ARE LETHAL — FORCE ENEMIES INTO WALLS<br>TWO-LEVEL ARENA WITH RAMPS</div>
  </div>
  <div id="scr-round" class="overlay hidden">
    <div class="ov-title cyan" id="round-title">ROUND 1</div>
    <div class="ov-sub" id="round-sub">3 OPPONENTS</div>
    <button class="ov-btn" id="btn-round">▶ RIDE</button>
  </div>
  <div id="scr-dead" class="overlay hidden">
    <div class="ov-title red">DEREZZED</div>
    <div class="ov-sub" id="dead-info"></div>
    <button class="ov-btn" id="btn-retry">▶ REBOOT</button>
  </div>
  <div id="scr-win" class="overlay hidden">
    <div class="ov-title green">VICTORY</div>
    <div class="ov-sub" id="win-info"></div>
    <button class="ov-btn" id="btn-next">▶ NEXT ROUND</button>
  </div>
</div>
<div id="controls">
  <div class="stick-wrap"><div class="stick-zone" id="sz-steer"><div class="stick-base"></div><div class="stick-knob" id="sk-steer"></div></div><div class="stick-label">STEER</div></div>
  <div id="ctrl-center"><div id="speed-display">0</div><div id="speed-label">VELOCITY</div><div id="floor-ind">LOWER</div><div id="boost-outer"><div id="boost-bar"></div></div></div>
  <div class="stick-wrap"><div class="stick-zone" id="sz-thr"><div class="stick-base"></div><div class="stick-knob thr" id="sk-thr"></div></div><div class="stick-label">SPEED</div></div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
//  GRID_RUNNER — LIGHT CYCLE ARENA
// ============================================================
const TILE=4, AW=50, AH=50;
const AX=AW*TILE, AZ=AH*TILE;
const LVL_H=8, WALL_H=3.5;
const MIN_SPEED=8, MAX_SPEED=18, BOOST_SPEED=28;

let state='title', round=1, wins=0, score=0, gt=0;
let player=null, riders=[], trailSegs=[];
let rampZones=[], upperBounds=null;

// --- THREE ---
const viewport=document.getElementById('viewport');
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x000010);
scene.fog=new THREE.FogExp2(0x000818,0.004);
const camera=new THREE.PerspectiveCamera(75,1,0.1,600);
const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
viewport.insertBefore(renderer.domElement,viewport.firstChild);
function onResize(){const w=viewport.clientWidth,h=viewport.clientHeight;if(!w||!h)return;camera.aspect=w/h;camera.updateProjectionMatrix();renderer.setSize(w,h)}
onResize();window.addEventListener('resize',onResize);new ResizeObserver(onResize).observe(viewport);
const mmC=document.getElementById('minimap'),mmX=mmC.getContext('2d');

scene.add(new THREE.AmbientLight(0x112244,0.5));
const dl1=new THREE.DirectionalLight(0x0088ff,0.4);dl1.position.set(50,100,50);scene.add(dl1);

// --- MATERIALS ---
const matFloor=new THREE.MeshStandardMaterial({color:0x000818,emissive:0x001122,roughness:0.9});
const matGlass=new THREE.MeshStandardMaterial({color:0x001828,emissive:0x003355,emissiveIntensity:0.15,roughness:0.2,transparent:true,opacity:0.5});
const matWall=new THREE.MeshStandardMaterial({color:0x081828,emissive:0x0066cc,emissiveIntensity:0.2,roughness:0.5,transparent:true,opacity:0.8});
const matRamp=new THREE.MeshStandardMaterial({color:0x0a1a2a,emissive:0x0088cc,emissiveIntensity:0.15,roughness:0.4,metalness:0.6});
const matRampGlow=new THREE.MeshStandardMaterial({color:0x00ccff,emissive:0x00ccff,emissiveIntensity:0.8});
const matEdge=new THREE.MeshStandardMaterial({color:0x00ccff,emissive:0x00ccff,emissiveIntensity:0.6});

// ============================================================
//  ARENA
// ============================================================
let arenaGrp=new THREE.Group();scene.add(arenaGrp);

function buildArena(){
  while(arenaGrp.children.length>0){const c=arenaGrp.children[0];arenaGrp.remove(c)}
  rampZones=[];
  const cx=AX/2,cz=AZ/2;

  // LOWER FLOOR
  const lf=new THREE.Mesh(new THREE.PlaneGeometry(AX,AZ),matFloor);
  lf.rotation.x=-Math.PI/2;lf.position.set(cx,0.01,cz);arenaGrp.add(lf);
  const g1=new THREE.GridHelper(AX,AW,0x003366,0x001133);g1.position.set(cx,0.05,cz);arenaGrp.add(g1);
  const g2=new THREE.GridHelper(AX,AW/10,0x0066cc,0x003388);g2.position.set(cx,0.06,cz);arenaGrp.add(g2);

  // UPPER PLATFORM (glass, ~55%)
  const upW=AX*0.55,upD=AZ*0.55;
  const uf=new THREE.Mesh(new THREE.PlaneGeometry(upW,upD),matGlass);
  uf.rotation.x=-Math.PI/2;uf.position.set(cx,LVL_H,cz);arenaGrp.add(uf);
  const g3=new THREE.GridHelper(upW,Math.floor(upW/TILE),0x004488,0x002244);g3.position.set(cx,LVL_H+0.04,cz);arenaGrp.add(g3);
  // Edge borders
  for(let s=-1;s<=1;s+=2){
    const ez=new THREE.Mesh(new THREE.BoxGeometry(upW,0.2,0.15),matEdge);ez.position.set(cx,LVL_H,cz+s*upD/2);arenaGrp.add(ez);
    const ex=new THREE.Mesh(new THREE.BoxGeometry(0.15,0.2,upD),matEdge);ex.position.set(cx+s*upW/2,LVL_H,cz);arenaGrp.add(ex);
  }
  // Pillars
  const pGeo=new THREE.CylinderGeometry(0.35,0.35,LVL_H,8);
  const pMat=new THREE.MeshStandardMaterial({color:0x002244,emissive:0x0088cc,emissiveIntensity:0.25,transparent:true,opacity:0.6});
  [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([sx,sz])=>{
    const p=new THREE.Mesh(pGeo,pMat);p.position.set(cx+sx*(upW/2-2),LVL_H/2,cz+sz*(upD/2-2));arenaGrp.add(p);
  });
  upperBounds={x1:cx-upW/2,z1:cz-upD/2,x2:cx+upW/2,z2:cz+upD/2};

  // ARENA WALLS
  for(let s=-1;s<=1;s+=2){
    arenaGrp.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(AX,WALL_H,0.6),matWall),{position:new THREE.Vector3(cx,WALL_H/2,cz+s*AZ/2)}));
    arenaGrp.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.6,WALL_H,AZ),matWall),{position:new THREE.Vector3(cx+s*AX/2,WALL_H/2,cz)}));
  }
  // Upper level walls too
  for(let s=-1;s<=1;s+=2){
    arenaGrp.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(upW,1.5,0.3),matWall),{position:new THREE.Vector3(cx,LVL_H+0.75,cz+s*upD/2)}));
    arenaGrp.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.3,1.5,upD),matWall),{position:new THREE.Vector3(cx+s*upW/2,LVL_H+0.75,cz)}));
  }

  // RAMPS — 4 cardinal, simple inclined planes
  const rLen=22, rWid=7;
  const rDefs=[
    {dx:0,dz:-1, x:cx, z:cz-upD/2-rLen/2+1},
    {dx:0,dz:1,  x:cx, z:cz+upD/2+rLen/2-1},
    {dx:-1,dz:0, x:cx-upW/2-rLen/2+1, z:cz},
    {dx:1,dz:0,  x:cx+upW/2+rLen/2-1, z:cz}
  ];
  rDefs.forEach(rd=>{
    const isZ=rd.dz!==0;
    const rGeo=new THREE.BoxGeometry(isZ?rWid:rLen, 0.2, isZ?rLen:rWid);
    const rM=new THREE.Mesh(rGeo,matRamp);
    rM.position.set(rd.x,LVL_H/2,rd.z);
    const rAngle=Math.atan2(LVL_H,rLen);
    if(isZ) rM.rotation.x=rAngle*(rd.dz>0?1:-1);
    else rM.rotation.z=rAngle*(rd.dx>0?-1:1);
    arenaGrp.add(rM);
    // Edge strips
    for(let s=-1;s<=1;s+=2){
      const eg=new THREE.Mesh(new THREE.BoxGeometry(isZ?0.12:rLen,0.15,isZ?rLen:0.12),matRampGlow);
      eg.position.set(rd.x+(isZ?s*rWid/2:0),LVL_H/2,rd.z+(isZ?0:s*rWid/2));
      if(isZ) eg.rotation.x=rM.rotation.x; else eg.rotation.z=rM.rotation.z;
      arenaGrp.add(eg);
    }
    // Arrow indicators on ramp
    for(let i=0;i<3;i++){
      const ag=new THREE.Mesh(new THREE.BoxGeometry(isZ?1.5:0.15,0.06,isZ?0.15:1.5),matRampGlow);
      const frac=(i+1)/4;
      const ry=frac*LVL_H;
      if(isZ){ag.position.set(rd.x,ry,rd.z+rd.dz*(rLen/2-frac*rLen))}
      else{ag.position.set(rd.x+rd.dx*(rLen/2-frac*rLen),ry,rd.z)}
      arenaGrp.add(ag);
    }
    // Collision zone
    rampZones.push({
      x:rd.x, z:rd.z, dx:rd.dx, dz:rd.dz,
      halfW:isZ?rWid/2:rLen/2, halfD:isZ?rLen/2:rWid/2,
      contains(px,pz){return Math.abs(px-this.x)<this.halfW && Math.abs(pz-this.z)<this.halfD},
      getY(px,pz){
        let t;
        if(isZ){
          // dz=-1: low at +z, high at -z; dz=1: low at -z, high at +z
          const bottom=this.z+rd.dz*this.halfD; // far edge from platform
          const top=this.z-rd.dz*this.halfD;     // near edge to platform
          t=(pz-bottom)/(top-bottom);
        } else {
          const bottom=this.x+rd.dx*this.halfW;
          const top=this.x-rd.dx*this.halfW;
          t=(px-bottom)/(top-bottom);
        }
        return Math.max(0,Math.min(LVL_H,t*LVL_H));
      }
    });
  });
}

function getY(px,pz){
  for(const r of rampZones){if(r.contains(px,pz))return r.getY(px,pz)}
  if(upperBounds && px>upperBounds.x1 && px<upperBounds.x2 && pz>upperBounds.z1 && pz<upperBounds.z2) return LVL_H;
  return 0;
}

// ============================================================
//  LIGHT CYCLE — wider motorcycle from blueprint
// ============================================================
function buildCycle(col){
  const g=new THREE.Group();
  const gc=new THREE.Color(col);
  const dk=new THREE.MeshStandardMaterial({color:0x080810,emissive:gc,emissiveIntensity:0.03,roughness:0.3,metalness:0.9});
  const gl=new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:1.2,roughness:0.1});
  const gd=new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:0.5});

  const WR=0.7,WT=0.14,BW=0.6;

  // Rear wheel
  const rw=new THREE.Mesh(new THREE.TorusGeometry(WR,WT,10,28),gl);rw.rotation.y=Math.PI/2;rw.position.set(0,WR,-1.9);g.add(rw);
  const rwf=new THREE.Mesh(new THREE.CylinderGeometry(WR-0.03,WR-0.03,0.2,28),dk);rwf.rotation.z=Math.PI/2;rwf.position.set(0,WR,-1.9);g.add(rwf);
  // Front wheel
  const fw=new THREE.Mesh(new THREE.TorusGeometry(WR,WT,10,28),gl);fw.rotation.y=Math.PI/2;fw.position.set(0,WR,2.1);g.add(fw);
  const fwf=new THREE.Mesh(new THREE.CylinderGeometry(WR-0.03,WR-0.03,0.2,28),dk);fwf.rotation.z=Math.PI/2;fwf.position.set(0,WR,2.1);g.add(fwf);

  // Chassis (wide extruded profile)
  const cs=new THREE.Shape();
  cs.moveTo(2.4,0.5);cs.quadraticCurveTo(1.6,0.9,0.8,1.05);
  cs.quadraticCurveTo(0,1.12,-0.4,1.0);cs.quadraticCurveTo(-1.0,0.8,-1.6,0.55);
  cs.lineTo(-1.9,0.45);cs.lineTo(-1.9,0.25);cs.quadraticCurveTo(-0.5,0.12,0.5,0.12);
  cs.quadraticCurveTo(1.5,0.18,2.2,0.35);cs.lineTo(2.4,0.5);
  const cGeo=new THREE.ExtrudeGeometry(cs,{steps:1,depth:BW,bevelEnabled:true,bevelThickness:0.06,bevelSize:0.06,bevelSegments:2});
  cGeo.translate(0,0,-BW/2);
  const cM=new THREE.Mesh(cGeo,dk);cM.rotation.y=Math.PI/2;g.add(cM);

  // Rider
  const torso=new THREE.Mesh(new THREE.BoxGeometry(0.55,0.5,0.55),dk);torso.position.set(0,1.35,0.1);torso.rotation.x=0.4;g.add(torso);
  const head=new THREE.Mesh(new THREE.SphereGeometry(0.19,8,6),dk);head.position.set(0,1.65,0.5);g.add(head);
  g.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.36,0.07,0.1),gl),{position:new THREE.Vector3(0,1.63,0.68)}));
  for(let s=-1;s<=1;s+=2){
    const arm=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.05,0.55,6),dk);arm.position.set(s*0.33,1.15,0.6);arm.rotation.x=1.1;g.add(arm);
    {const m=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.5),gl);m.position.set(s*0.33,1.17,0.6);m.rotation.set(1.1,0,0);g.add(m)}
    {const m=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.55),gl);m.position.set(s*0.16,1.35,0.1);m.rotation.set(0.4,0,0);g.add(m)}
  }

  // Flowing glow curves
  function mkC(xo){
    const pts=[new THREE.Vector3(xo,0.45,2.4),new THREE.Vector3(xo*1.15,0.6,1.4),new THREE.Vector3(xo*1.25,0.9,0.4),
      new THREE.Vector3(xo*1.2,1.05,-0.2),new THREE.Vector3(xo*1.1,0.85,-1.0),new THREE.Vector3(xo,0.6,-1.7),new THREE.Vector3(xo*0.9,0.48,-2.2)];
    return new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts),24,0.03,6,false),gl);
  }
  g.add(mkC(-0.35));g.add(mkC(0.35));
  function mkC2(xo){
    const pts=[new THREE.Vector3(xo,0.55,1.8),new THREE.Vector3(xo*1.1,0.75,0.6),new THREE.Vector3(xo*1.15,0.95,-0.1),
      new THREE.Vector3(xo*1.05,0.78,-0.9),new THREE.Vector3(xo,0.55,-1.7)];
    return new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts),16,0.02,5,false),gd);
  }
  g.add(mkC2(-0.22));g.add(mkC2(0.22));

  // Spine
  const sp=[new THREE.Vector3(0,1.08,-1.5),new THREE.Vector3(0,1.14,-0.2),new THREE.Vector3(0,1.15,0.5),new THREE.Vector3(0,0.92,1.3)];
  g.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(sp),10,0.025,5,false),gl));

  // Engine
  g.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.7),dk),{position:new THREE.Vector3(0,0.35,0)}));
  for(let i=0;i<3;i++) g.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.52,0.025,0.05),
    new THREE.MeshStandardMaterial({color:0xaaaa00,emissive:0xaaaa00,emissiveIntensity:0.7})),{position:new THREE.Vector3(0,0.25+i*0.09,-0.22+i*0.14)}));

  // Exhaust, headlight, underglow
  g.add(Object.assign(new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.05),gl),{position:new THREE.Vector3(0,0.5,-2.25)}));
  g.add(Object.assign(new THREE.Mesh(new THREE.SphereGeometry(0.08,8,6),gl),{position:new THREE.Vector3(0,0.72,2.55)}));
  const ugm=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.1,side:THREE.DoubleSide});
  const ug=new THREE.Mesh(new THREE.PlaneGeometry(0.7,4.8),ugm);ug.rotation.x=-Math.PI/2;ug.position.set(0,0.02,0);g.add(ug);

  return g;
}

// ============================================================
//  TRAILS — spatial grid for fast collision
// ============================================================
const TRAIL_H=2.2;
const GRID_SIZE=2; // spatial hash cell size
let trailGrid={};

function trailKey(x,z){return Math.floor(x/GRID_SIZE)+'_'+Math.floor(z/GRID_SIZE)}
function addTrail(r){
  const mat=new THREE.MeshBasicMaterial({color:r.color,transparent:true,opacity:0.75,side:THREE.DoubleSide});
  const geo=new THREE.PlaneGeometry(0.8,TRAIL_H);
  const m=new THREE.Mesh(geo,mat);
  const gy=r.gy||0;
  m.position.set(r.x,gy+TRAIL_H/2+0.05,r.z);m.rotation.y=r.angle+Math.PI/2;
  scene.add(m);
  const seg={x:r.x,z:r.z,y:gy,mesh:m,oid:r.id,age:0};
  r.trail.push(seg);trailSegs.push(seg);
  // Spatial hash
  const k=trailKey(r.x,r.z);if(!trailGrid[k])trailGrid[k]=[];trailGrid[k].push(seg);
}
function hitTrail(px,pz,py,oid){
  // Check nearby cells only
  const cx=Math.floor(px/GRID_SIZE),cz=Math.floor(pz/GRID_SIZE);
  for(let dx=-1;dx<=1;dx++){for(let dz=-1;dz<=1;dz++){
    const k=(cx+dx)+'_'+(cz+dz);const cell=trailGrid[k];if(!cell)continue;
    for(const s of cell){
      if(s.oid===oid&&s.age<0.6)continue; // own trail grace
      if(Math.abs(s.y-py)>TRAIL_H)continue; // different level
      if(Math.hypot(px-s.x,pz-s.z)<1.3)return true;
    }
  }}
  return false;
}

// ============================================================
//  RIDERS
// ============================================================
let nextId=0;
const P_COL=0x00ffcc, E_COLS=[0xff2200,0xff4400,0xff0044,0xcc4400,0xaa0000];

function mkRider(isP,col,x,z,a){
  const mesh=buildCycle(col);mesh.position.set(x,0,z);mesh.rotation.y=a;scene.add(mesh);
  const light=new THREE.PointLight(col,1.5,20);scene.add(light);
  return{id:nextId++,isP,color:col,mesh,light,x,z,angle:a,speed:MIN_SPEED,gy:0,alive:true,trail:[],tt:0,aiTurn:0,aiNext:0};
}
function killRider(r){
  if(!r.alive)return;r.alive=false;scene.remove(r.mesh);scene.remove(r.light);
  // Flash trail then schedule fade
  r.trail.forEach(s=>{if(s.mesh.material)s.mesh.material.opacity=0.3});
  addMsg(r.isP?'DEREZZED':'OPPONENT ELIMINATED');
  if(!r.isP)score+=100;
}

// ============================================================
//  AI — avoid walls/trails, occasional 90° turns
// ============================================================
function aiUpdate(r,dt){
  if(!r.alive||r.isP)return;
  r.aiTurn-=dt;r.aiNext-=dt;
  r.speed+=(MIN_SPEED*1.1-r.speed)*2*dt; // cruise near min speed

  const look=r.speed*0.4+5;
  const ax=r.x+Math.sin(r.angle)*look, az=r.z+Math.cos(r.angle)*look;
  const gy=r.gy;
  let danger=ax<4||ax>AX-4||az<4||az>AZ-4;
  if(!danger)danger=hitTrail(ax,az,gy,r.id);
  // Check closer too
  if(!danger){const ax2=r.x+Math.sin(r.angle)*look*0.4,az2=r.z+Math.cos(r.angle)*look*0.4;danger=hitTrail(ax2,az2,gy,r.id)}

  if(danger&&r.aiTurn<=0){
    const ta=Math.PI/2;
    const lx=r.x+Math.sin(r.angle+ta)*look,lz=r.z+Math.cos(r.angle+ta)*look;
    const rx=r.x+Math.sin(r.angle-ta)*look,rz=r.z+Math.cos(r.angle-ta)*look;
    const lOk=!hitTrail(lx,lz,gy,r.id)&&lx>3&&lx<AX-3&&lz>3&&lz<AZ-3;
    const rOk=!hitTrail(rx,rz,gy,r.id)&&rx>3&&rx<AX-3&&rz>3&&rz<AZ-3;
    if(lOk&&!rOk)r.angle+=ta;
    else if(rOk&&!lOk)r.angle-=ta;
    else r.angle+=(Math.random()>0.5?1:-1)*ta;
    r.aiTurn=0.35+Math.random()*0.25;
  }
  // Random turns
  if(r.aiNext<=0){r.aiNext=2+Math.random()*3;
    if(Math.random()<0.3&&r.aiTurn<=0){r.angle+=(Math.random()>0.5?1:-1)*Math.PI/2;r.aiTurn=0.4}}
}

// ============================================================
//  INPUT
// ============================================================
function mkStick(zId,kId){
  const z=document.getElementById(zId),k=document.getElementById(kId);
  const s={x:0,y:0,tid:null,md:false};
  function calc(cx,cy,clx,cly){let dx=clx-cx,dy=cly-cy;const mr=z.clientWidth/2-10,d=Math.hypot(dx,dy);if(d>mr){dx=dx/d*mr;dy=dy/d*mr}s.x=dx/mr;s.y=dy/mr;k.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`}
  function rst(){s.x=0;s.y=0;s.tid=null;s.md=false;k.style.transform='translate(-50%,-50%)';k.classList.remove('active')}
  z.addEventListener('touchstart',e=>{e.preventDefault();s.tid=e.changedTouches[0].identifier;k.classList.add('active')},{passive:false});
  z.addEventListener('touchmove',e=>{e.preventDefault();for(const t of e.changedTouches)if(t.identifier===s.tid){const r=z.getBoundingClientRect();calc(r.left+r.width/2,r.top+r.height/2,t.clientX,t.clientY)}},{passive:false});
  z.addEventListener('touchend',e=>{for(const t of e.changedTouches)if(t.identifier===s.tid)rst()});
  z.addEventListener('touchcancel',e=>{for(const t of e.changedTouches)if(t.identifier===s.tid)rst()});
  z.addEventListener('mousedown',e=>{e.preventDefault();s.md=true;k.classList.add('active')});
  window.addEventListener('mousemove',e=>{if(!s.md)return;const r=z.getBoundingClientRect();calc(r.left+r.width/2,r.top+r.height/2,e.clientX,e.clientY)});
  window.addEventListener('mouseup',()=>{if(s.md)rst()});
  return s;
}
const steerS=mkStick('sz-steer','sk-steer'), thrS=mkStick('sz-thr','sk-thr');
document.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});
let keys={};window.addEventListener('keydown',e=>{keys[e.code]=true});window.addEventListener('keyup',e=>{keys[e.code]=false});
function inp(){
  let st=0,th=0;
  if(keys['KeyA']||keys['ArrowLeft'])st=-1;if(keys['KeyD']||keys['ArrowRight'])st=1;
  if(keys['KeyW']||keys['ArrowUp'])th=1;if(keys['KeyS']||keys['ArrowDown'])th=-0.5;
  if(keys['Space'])th=1.5;
  if(Math.abs(steerS.x)>0.1)st+=steerS.x;
  if(Math.abs(thrS.y)>0.1)th-=thrS.y;
  return{st:Math.max(-1,Math.min(1,st)),th:Math.max(-0.5,Math.min(1.5,th))};
}

// ============================================================
//  UPDATE
// ============================================================
function update(dt){
  if(state!=='playing')return;gt+=dt;
  const i=inp();

  riders.forEach(r=>{
    if(!r.alive)return;

    if(r.isP){
      r.angle-=i.st*3.2*dt;
      const target=i.th>1?BOOST_SPEED:(i.th>0.1?MAX_SPEED:(i.th<-0.1?MIN_SPEED*0.5:MIN_SPEED));
      r.speed+=(target-r.speed)*4*dt;
      if(r.speed<MIN_SPEED*0.4)r.speed+=12*dt; // always move
    }else{
      aiUpdate(r,dt);
    }

    const nx=r.x+Math.sin(r.angle)*r.speed*dt;
    const nz=r.z+Math.cos(r.angle)*r.speed*dt;

    // Wall collision
    if(nx<1||nx>AX-1||nz<1||nz>AZ-1){killRider(r);return}
    // Upper platform edge collision (if on upper level and moving off edge)
    if(r.gy>=LVL_H-0.5 && upperBounds){
      const onRamp=rampZones.some(rz=>rz.contains(nx,nz));
      const onUpper=nx>upperBounds.x1&&nx<upperBounds.x2&&nz>upperBounds.z1&&nz<upperBounds.z2;
      if(!onUpper&&!onRamp){
        // Fell off — derez
        killRider(r);return;
      }
    }

    r.x=nx;r.z=nz;
    r.gy=getY(r.x,r.z);

    // Trail collision
    if(hitTrail(r.x,r.z,r.gy,r.id)){killRider(r);return}

    // Lay trail
    r.tt+=dt;
    if(r.speed>3&&r.tt>0.04){r.tt=0;addTrail(r)}

    r.mesh.position.set(r.x,r.gy,r.z);r.mesh.rotation.y=r.angle;
    if(r.isP)r.mesh.rotation.z=i.st*0.15;
    r.light.position.set(r.x,r.gy+2.5,r.z);
  });

  // Age trails
  for(let j=trailSegs.length-1;j>=0;j--){
    trailSegs[j].age+=dt;
  }

  // Camera
  if(player&&player.alive){
    const cd=8,ch=5;
    const cx=player.x-Math.sin(player.angle)*cd,cz=player.z-Math.cos(player.angle)*cd;
    camera.position.lerp(new THREE.Vector3(cx,player.gy+ch,cz),0.08);
    camera.lookAt(new THREE.Vector3(player.x+Math.sin(player.angle)*10,player.gy+1.5,player.z+Math.cos(player.angle)*10));
  }

  // Win/lose check
  const aliveE=riders.filter(r=>r.alive&&!r.isP).length;
  if(player&&!player.alive&&state==='playing'){
    state='dead';
    setTimeout(()=>{document.getElementById('scr-dead').classList.remove('hidden');document.getElementById('dead-info').textContent='ROUND '+round+' — SCORE '+score},800);
  } else if(aliveE===0&&player&&player.alive&&state==='playing'){
    wins++;score+=round*200;state='win';
    setTimeout(()=>{document.getElementById('scr-win').classList.remove('hidden');document.getElementById('win-info').textContent='ROUND '+round+' CLEAR — SCORE '+score},600);
  }

  updHUD();
  document.getElementById('speed-display').textContent=Math.floor(player.speed*10);
  document.getElementById('boost-bar').style.width=Math.min(100,player.speed/MAX_SPEED*100)+'%';
  document.getElementById('floor-ind').textContent=player.gy>LVL_H*0.4?'UPPER LEVEL':'LOWER LEVEL';
}

function updHUD(){
  document.getElementById('alive-val').textContent=riders.filter(r=>r.alive&&!r.isP).length;
  document.getElementById('round-val').textContent=round;
  document.getElementById('wins-val').textContent=wins;
  document.getElementById('score-val').textContent=score;
}
function addMsg(t){const el=document.createElement('div');el.className='message';el.textContent=t;document.getElementById('messages').appendChild(el);setTimeout(()=>el.remove(),3000)}

function drawMM(){
  mmX.fillStyle='#000a18';mmX.fillRect(0,0,150,150);const s=150/AX;
  if(upperBounds){mmX.strokeStyle='#0af3';mmX.lineWidth=1;mmX.strokeRect(upperBounds.x1*s,upperBounds.z1*s,(upperBounds.x2-upperBounds.x1)*s,(upperBounds.z2-upperBounds.z1)*s)}
  mmX.fillStyle='#0af2';rampZones.forEach(r=>{mmX.fillRect((r.x-r.halfW)*s,(r.z-r.halfD)*s,r.halfW*2*s,r.halfD*2*s)});
  mmX.strokeStyle='#0664';mmX.strokeRect(0,0,AX*s,AZ*s);
  trailSegs.forEach(seg=>{const owner=riders.find(r=>r.id===seg.oid);mmX.fillStyle=owner&&owner.isP?'#0fc4':'#f224';mmX.fillRect(seg.x*s,seg.z*s,1.2,1.2)});
  riders.forEach(r=>{if(!r.alive)return;mmX.fillStyle=r.isP?'#0ff':'#f22';mmX.beginPath();mmX.arc(r.x*s,r.z*s,3,0,Math.PI*2);mmX.fill();
    mmX.strokeStyle=mmX.fillStyle;mmX.lineWidth=1.5;mmX.beginPath();mmX.moveTo(r.x*s,r.z*s);mmX.lineTo(r.x*s+Math.sin(r.angle)*8,r.z*s+Math.cos(r.angle)*8);mmX.stroke()});
}

// ============================================================
//  INIT ROUND
// ============================================================
function initRound(){
  riders.forEach(r=>{scene.remove(r.mesh);scene.remove(r.light)});
  trailSegs.forEach(s=>{scene.remove(s.mesh);s.mesh.geometry.dispose()});
  riders=[];trailSegs=[];trailGrid={};gt=0;nextId=0;
  buildArena();
  const cx=AX/2,cz=AZ/2,sr=35;
  player=mkRider(true,P_COL,cx,cz+sr,0);riders.push(player);
  const ne=Math.min(1+round,5);
  for(let i=0;i<ne;i++){
    const a=(i/ne)*Math.PI*2+Math.PI;
    riders.push(mkRider(false,E_COLS[i%E_COLS.length],cx+Math.cos(a)*sr,cz+Math.sin(a)*sr,a+Math.PI));
  }
}

// ============================================================
//  GAME FLOW
// ============================================================
function showScreen(id){document.querySelectorAll('.overlay').forEach(e=>e.classList.add('hidden'));
  if(id)document.getElementById(id).classList.remove('hidden')}
function startGame(){round=1;wins=0;score=0;showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND 1';document.getElementById('round-sub').textContent='2 OPPONENTS'}
function startRound(){showScreen(null);state='playing';initRound()}
function nextRound(){round++;showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND '+round;document.getElementById('round-sub').textContent=Math.min(1+round,5)+' OPPONENTS'}
function retry(){round=1;wins=0;score=0;showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND 1';document.getElementById('round-sub').textContent='2 OPPONENTS'}

document.getElementById('btn-start').addEventListener('click',e=>{e.preventDefault();startGame()});
document.getElementById('btn-round').addEventListener('click',e=>{e.preventDefault();startRound()});
document.getElementById('btn-next').addEventListener('click',e=>{e.preventDefault();nextRound()});
document.getElementById('btn-retry').addEventListener('click',e=>{e.preventDefault();retry()});
window.addEventListener('keydown',e=>{
  if(e.code==='Enter'||e.code==='Space'){
    if(state==='title')startGame();
    else if(state==='roundStart')startRound();
    else if(state==='win')nextRound();
    else if(state==='dead')retry();
  }
});

let lastT=0;
function loop(t){requestAnimationFrame(loop);const dt=Math.min(0.05,(t-lastT)/1000);lastT=t;
  if(state==='playing')update(dt);
  renderer.render(scene,camera);
  if(state==='playing')drawMM();
}
requestAnimationFrame(loop);
</script>
</body></html>
