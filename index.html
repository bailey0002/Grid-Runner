<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>GRID_RUNNER 3D â€” LIGHT CYCLE</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap');
*{margin:0;padding:0;box-sizing:border-box}
html,body{width:100%;height:100%;overflow:hidden;touch-action:none;background:#000008;font-family:'Orbitron',sans-serif;color:#0ff}
#app{display:flex;flex-direction:column;height:100%;width:100%}
#viewport{position:relative;flex:1;min-height:0;background:#000}
#viewport canvas{display:block;width:100%!important;height:100%!important}
#hud{position:absolute;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;pointer-events:none;z-index:10}
.hp{background:rgba(0,5,20,0.82);border:1px solid #0af3;border-radius:4px;padding:5px 10px;font-size:10px;letter-spacing:1.2px;display:flex;gap:12px;align-items:center;text-transform:uppercase}
.st{display:flex;align-items:center;gap:4px}
.sl{color:#0af8;font-size:8px;font-family:'Share Tech Mono',monospace}
.sv{color:#0ff;font-weight:700;font-size:11px;text-shadow:0 0 8px #0ff4}
#pip{position:absolute;bottom:8px;left:8px;width:150px;height:150px;border:1px solid #0af4;border-radius:4px;background:rgba(0,5,15,0.85);z-index:10}
#pip canvas{width:100%;height:100%;border-radius:3px}
#pip-label{position:absolute;top:3px;left:6px;font-size:7px;color:#0af8;letter-spacing:2px;font-family:'Share Tech Mono',monospace}
#messages{position:absolute;top:40px;left:50%;transform:translateX(-50%);pointer-events:none;z-index:10;display:flex;flex-direction:column;gap:3px;align-items:center}
.message{background:rgba(0,5,20,0.9);border:1px solid #0af3;border-radius:3px;padding:4px 14px;font-size:10px;font-family:'Share Tech Mono',monospace;color:#0ff;letter-spacing:1px;text-shadow:0 0 6px #0ff4;animation:msgFade 3s forwards;white-space:nowrap}
@keyframes msgFade{0%{opacity:1}70%{opacity:1}100%{opacity:0;transform:translateY(-10px)}}
#controls{height:150px;min-height:150px;background:linear-gradient(180deg,#000a18 0%,#000510 100%);border-top:1px solid #0af3;display:flex;align-items:center;justify-content:space-between;padding:8px 16px}
.stick-wrap{display:flex;flex-direction:column;align-items:center;gap:3px;flex-shrink:0}
.stick-zone{width:110px;height:110px;position:relative}
.stick-base{position:absolute;inset:0;border:2px solid #0af4;border-radius:50%;background:rgba(0,10,30,0.5)}
.stick-knob{position:absolute;width:42px;height:42px;top:50%;left:50%;transform:translate(-50%,-50%);border:2px solid #0ff;border-radius:50%;background:rgba(0,255,255,0.15);box-shadow:0 0 16px rgba(0,255,255,0.3)}
.stick-knob.thr{border-color:#ff0;background:rgba(255,255,0,0.12);box-shadow:0 0 16px rgba(255,255,0,0.2)}
.stick-knob.active{background:rgba(0,255,255,0.3)}.stick-knob.thr.active{background:rgba(255,255,0,0.3)}
.stick-label{font-size:7px;color:#0af8;letter-spacing:2px;font-family:'Share Tech Mono',monospace}
#ctrl-center{display:flex;flex-direction:column;align-items:center;gap:3px;flex:1}
#speed-display{font-size:30px;font-weight:900;color:#0ff;text-shadow:0 0 12px #0ff4;font-family:'Orbitron',sans-serif}
#speed-label{font-size:7px;color:#0af8;letter-spacing:3px;font-family:'Share Tech Mono',monospace}
#boost-outer{width:110px;height:5px;background:#0a0a20;border:1px solid #0af3;border-radius:3px;overflow:hidden;margin-top:3px}
#boost-bar{height:100%;background:linear-gradient(90deg,#ff0,#f80);border-radius:2px;width:100%}
#floor-ind{font-size:8px;color:#0af;letter-spacing:2px;font-family:'Share Tech Mono',monospace;margin-top:2px}
.overlay{position:absolute;inset:0;z-index:200;display:flex;flex-direction:column;align-items:center;justify-content:center;background:rgba(0,0,8,0.92)}
.overlay.hidden{display:none}
.ov-title{font-size:clamp(28px,7vw,48px);font-weight:900;letter-spacing:10px;margin-bottom:6px;text-shadow:0 0 30px currentColor}
.ov-title.cyan{color:#0ff}.ov-title.red{color:#f04}.ov-title.green{color:#0f8}
.ov-sub{font-size:clamp(10px,2vw,13px);letter-spacing:5px;color:#0af;margin-bottom:30px;font-family:'Share Tech Mono',monospace}
.ov-btn{padding:14px 40px;border:2px solid #0ff;border-radius:4px;background:rgba(0,255,255,0.08);color:#0ff;font-family:'Orbitron',sans-serif;font-size:16px;font-weight:700;letter-spacing:5px;cursor:pointer;-webkit-tap-highlight-color:transparent;animation:pulse 1.5s ease-in-out infinite}
.ov-btn:active{background:rgba(0,255,255,0.25)}
.ov-info{margin-top:20px;font-size:9px;color:#0af6;letter-spacing:1.5px;font-family:'Share Tech Mono',monospace;text-align:center;line-height:2.2}
@keyframes pulse{0%,100%{opacity:0.6}50%{opacity:1}}

/* --- GAMEPAD MODE --- */
body.gp-mode #controls{display:none}
body.gp-mode #viewport{flex:1}
#gp-hud{display:none;position:absolute;bottom:12px;left:50%;transform:translateX(-50%);z-index:10;pointer-events:none;text-align:center}
body.gp-mode #gp-hud{display:flex;flex-direction:column;align-items:center;gap:2px}
#gp-speed{font-size:28px;font-weight:900;color:#0ff;text-shadow:0 0 12px #0ff6;font-family:'Orbitron',sans-serif}
#gp-speed-label{font-size:7px;color:#0af8;letter-spacing:3px;font-family:'Share Tech Mono',monospace}
#gp-boost-outer{width:120px;height:4px;background:#0a0a20;border:1px solid #0af3;border-radius:3px;overflow:hidden;margin-top:2px}
#gp-boost-bar{height:100%;background:linear-gradient(90deg,#ff0,#f80);border-radius:2px;width:100%;transition:width 0.1s}
#gp-floor{font-size:8px;color:#0af;letter-spacing:2px;font-family:'Share Tech Mono',monospace;margin-top:2px}
#gp-status{position:absolute;bottom:4px;right:8px;font-size:7px;color:#0af4;letter-spacing:1px;font-family:'Share Tech Mono',monospace;z-index:10;pointer-events:none}
</style>
</head>
<body>
<div id="app">
<div id="viewport">
  <div id="hud"><div class="hp"><div class="st"><span class="sl">ALIVE</span><span class="sv" id="alive-val">0</span></div><div class="st"><span class="sl">ROUND</span><span class="sv" id="round-val">1</span></div></div><div class="hp"><div class="st"><span class="sl">WINS</span><span class="sv" id="wins-val">0</span></div><div class="st"><span class="sl">SCORE</span><span class="sv" id="score-val">0</span></div></div></div>
  <div id="messages"></div>
  <div id="pip"><div id="pip-label">GRID MAP</div><canvas id="minimap" width="150" height="150"></canvas></div>
  <div id="gp-hud"><div id="gp-speed">0</div><div id="gp-speed-label">VELOCITY</div><div id="gp-floor">LOWER</div><div id="gp-boost-outer"><div id="gp-boost-bar"></div></div></div>
  <div id="gp-status"></div>
  <div id="scr-title" class="overlay">
    <div class="ov-title cyan">GRID_RUNNER</div>
    <div class="ov-sub">[ LIGHT CYCLE ARENA ]</div>
    <button class="ov-btn" id="btn-start">â–¶ ENTER GRID</button>
    <div class="ov-info">TOUCH: LEFT STICK=STEER â€¢ RIGHT STICK=THROTTLE<br>KEYBOARD: WASD / ARROWS + SPACE=BOOST<br>GAMEPAD: LEFT STICK=STEER â€¢ RT=GAS â€¢ A=BOOST<br><br>TRAILS ARE LETHAL â€” FORCE ENEMIES INTO WALLS</div>
  </div>
  <div id="scr-round" class="overlay hidden">
    <div class="ov-title cyan" id="round-title">ROUND 1</div>
    <div class="ov-sub" id="round-sub">3 OPPONENTS</div>
    <button class="ov-btn" id="btn-round">â–¶ RIDE</button>
  </div>
  <div id="scr-dead" class="overlay hidden">
    <div class="ov-title red">DEREZZED</div>
    <div class="ov-sub" id="dead-info"></div>
    <button class="ov-btn" id="btn-retry">â–¶ REBOOT</button>
  </div>
  <div id="scr-win" class="overlay hidden">
    <div class="ov-title green">VICTORY</div>
    <div class="ov-sub" id="win-info"></div>
    <button class="ov-btn" id="btn-next">â–¶ NEXT ROUND</button>
  </div>
</div>
<div id="controls">
  <div class="stick-wrap"><div class="stick-zone" id="sz-steer"><div class="stick-base"></div><div class="stick-knob" id="sk-steer"></div></div><div class="stick-label">STEER</div></div>
  <div id="ctrl-center"><div id="speed-display">0</div><div id="speed-label">VELOCITY</div><div id="floor-ind">LOWER</div><div id="boost-outer"><div id="boost-bar"></div></div></div>
  <div class="stick-wrap"><div class="stick-zone" id="sz-thr"><div class="stick-base"></div><div class="stick-knob thr" id="sk-thr"></div></div><div class="stick-label">SPEED</div></div>
</div>
</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
// ============================================================
//  GRID_RUNNER â€” LIGHT CYCLE ARENA  (debugged)
// ============================================================
const TILE=4, AW=70, AH=70;  // widened from 50x50
const AX=AW*TILE, AZ=AH*TILE;
const LVL_H=8, WALL_H=3.5;
const MIN_SPEED=8, MAX_SPEED=18, BOOST_SPEED=28;

let state='title', round=1, wins=0, score=0, gt=0;
let player=null, riders=[], trailSegs=[];
let rampZones=[], upperBounds=null;

// --- THREE ---
const viewport=document.getElementById('viewport');
const scene=new THREE.Scene();
scene.background=new THREE.Color(0x000010);
scene.fog=new THREE.FogExp2(0x000818, 0.0010);  // lighter fog for wider arena
const camera=new THREE.PerspectiveCamera(82,1,0.1,1000);
camera.position.set(AX/2, 60, AZ/2 + 100);
camera.lookAt(AX/2, 0, AZ/2);

const renderer=new THREE.WebGLRenderer({antialias:true});
renderer.setPixelRatio(Math.min(window.devicePixelRatio,2));
viewport.insertBefore(renderer.domElement, viewport.firstChild);

function onResize(){
  const w=viewport.clientWidth, h=viewport.clientHeight;
  if(!w||!h) return;
  camera.aspect=w/h;
  camera.updateProjectionMatrix();
  renderer.setSize(w,h);
}
onResize();
window.addEventListener('resize',onResize);
new ResizeObserver(onResize).observe(viewport);

const mmC=document.getElementById('minimap'), mmX=mmC.getContext('2d');

scene.add(new THREE.AmbientLight(0x112244, 0.6));
const dl1=new THREE.DirectionalLight(0x0088ff, 0.5);
dl1.position.set(50,100,50);
scene.add(dl1);
// FIX: add a second light from another angle for better visibility
const dl2=new THREE.DirectionalLight(0x004488, 0.3);
dl2.position.set(-50,80,-50);
scene.add(dl2);

// --- MATERIALS ---
const matFloor=new THREE.MeshStandardMaterial({color:0x000818,emissive:0x001122,roughness:0.9});
const matGlass=new THREE.MeshStandardMaterial({color:0x002040,emissive:0x0066aa,emissiveIntensity:0.25,roughness:0.15,transparent:true,opacity:0.35,side:THREE.DoubleSide});
const matWall=new THREE.MeshStandardMaterial({color:0x081828,emissive:0x0066cc,emissiveIntensity:0.2,roughness:0.5,transparent:true,opacity:0.8});
const matRamp=new THREE.MeshStandardMaterial({color:0x0a1a2a,emissive:0x0088cc,emissiveIntensity:0.15,roughness:0.4,metalness:0.6});
const matRampGlow=new THREE.MeshStandardMaterial({color:0x00ccff,emissive:0x00ccff,emissiveIntensity:0.8});
const matEdge=new THREE.MeshStandardMaterial({color:0x00ccff,emissive:0x00ccff,emissiveIntensity:0.6});

// ============================================================
//  ARENA
// ============================================================
let arenaGrp=new THREE.Group(); scene.add(arenaGrp);

function buildArena(){
  // Clear old arena children
  while(arenaGrp.children.length>0){
    const c=arenaGrp.children[0];
    arenaGrp.remove(c);
    if(c.geometry) c.geometry.dispose();
    if(c.material) {
      if(Array.isArray(c.material)) c.material.forEach(m=>m.dispose());
      else c.material.dispose();
    }
  }
  rampZones=[];
  const cx=AX/2, cz=AZ/2;

  // LOWER FLOOR
  const lf=new THREE.Mesh(new THREE.PlaneGeometry(AX,AZ),matFloor);
  lf.rotation.x=-Math.PI/2; lf.position.set(cx,0.01,cz); arenaGrp.add(lf);
  const g1=new THREE.GridHelper(AX,AW,0x003366,0x001133); g1.position.set(cx,0.05,cz); arenaGrp.add(g1);
  const g2=new THREE.GridHelper(AX,AW/10,0x0066cc,0x003388); g2.position.set(cx,0.06,cz); arenaGrp.add(g2);

  // UPPER PLATFORM (glass, ~55%)
  const upW=AX*0.55, upD=AZ*0.55;
  const uf=new THREE.Mesh(new THREE.PlaneGeometry(upW,upD),matGlass);
  uf.rotation.x=-Math.PI/2; uf.position.set(cx,LVL_H,cz); arenaGrp.add(uf);
  // Upper grid (top surface)
  const g3=new THREE.GridHelper(upW,Math.floor(upW/TILE),0x004488,0x002244);
  g3.position.set(cx,LVL_H+0.04,cz); arenaGrp.add(g3);
  // Underside glow â€” a subtle luminous plane visible from the lower level
  const matUnder=new THREE.MeshBasicMaterial({color:0x003366,transparent:true,opacity:0.12,side:THREE.DoubleSide});
  const ufUnder=new THREE.Mesh(new THREE.PlaneGeometry(upW,upD),matUnder);
  ufUnder.rotation.x=-Math.PI/2; ufUnder.position.set(cx,LVL_H-0.05,cz); arenaGrp.add(ufUnder);
  // Underside grid lines for depth cue from below
  const g3u=new THREE.GridHelper(upW,Math.floor(upW/(TILE*2)),0x003366,0x001a33);
  g3u.position.set(cx,LVL_H-0.08,cz); arenaGrp.add(g3u);

  // Edge borders â€” taller glow strips outlining the platform
  for(let s=-1;s<=1;s+=2){
    const ez=new THREE.Mesh(new THREE.BoxGeometry(upW,0.4,0.2),matEdge);
    ez.position.set(cx,LVL_H,cz+s*upD/2); arenaGrp.add(ez);
    const ex=new THREE.Mesh(new THREE.BoxGeometry(0.2,0.4,upD),matEdge);
    ex.position.set(cx+s*upW/2,LVL_H,cz); arenaGrp.add(ex);
  }

  // Pillars
  const pGeo=new THREE.CylinderGeometry(0.35,0.35,LVL_H,8);
  const pMat=new THREE.MeshStandardMaterial({color:0x002244,emissive:0x0088cc,emissiveIntensity:0.25,transparent:true,opacity:0.6});
  [[-1,-1],[-1,1],[1,-1],[1,1]].forEach(([sx,sz])=>{
    const p=new THREE.Mesh(pGeo,pMat);
    p.position.set(cx+sx*(upW/2-2),LVL_H/2,cz+sz*(upD/2-2));
    arenaGrp.add(p);
  });
  upperBounds={x1:cx-upW/2, z1:cz-upD/2, x2:cx+upW/2, z2:cz+upD/2};

  // ARENA WALLS
  for(let s=-1;s<=1;s+=2){
    const wz=new THREE.Mesh(new THREE.BoxGeometry(AX,WALL_H,0.6),matWall);
    wz.position.set(cx,WALL_H/2,cz+s*AZ/2); arenaGrp.add(wz);
    const wx=new THREE.Mesh(new THREE.BoxGeometry(0.6,WALL_H,AZ),matWall);
    wx.position.set(cx+s*AX/2,WALL_H/2,cz); arenaGrp.add(wx);
  }
  // Upper level walls
  for(let s=-1;s<=1;s+=2){
    const wz=new THREE.Mesh(new THREE.BoxGeometry(upW,1.5,0.3),matWall);
    wz.position.set(cx,LVL_H+0.75,cz+s*upD/2); arenaGrp.add(wz);
    const wx=new THREE.Mesh(new THREE.BoxGeometry(0.3,1.5,upD),matWall);
    wx.position.set(cx+s*upW/2,LVL_H+0.75,cz); arenaGrp.add(wx);
  }

  // RAMPS â€” 4 cardinal, simple inclined planes
  const rLen=22, rWid=7;
  const rDefs=[
    {dx:0,dz:-1, x:cx, z:cz-upD/2-rLen/2+1},
    {dx:0,dz:1,  x:cx, z:cz+upD/2+rLen/2-1},
    {dx:-1,dz:0, x:cx-upW/2-rLen/2+1, z:cz},
    {dx:1,dz:0,  x:cx+upW/2+rLen/2-1, z:cz}
  ];
  rDefs.forEach(rd=>{
    const isZ=rd.dz!==0;
    const rGeo=new THREE.BoxGeometry(isZ?rWid:rLen, 0.2, isZ?rLen:rWid);
    const rM=new THREE.Mesh(rGeo,matRamp);
    rM.position.set(rd.x, LVL_H/2, rd.z);
    const rAngle=Math.atan2(LVL_H,rLen);
    if(isZ) rM.rotation.x=rAngle*(rd.dz>0?1:-1);
    else rM.rotation.z=rAngle*(rd.dx>0?-1:1);
    arenaGrp.add(rM);
    // Edge strips
    for(let s=-1;s<=1;s+=2){
      const eg=new THREE.Mesh(new THREE.BoxGeometry(isZ?0.12:rLen,0.15,isZ?rLen:0.12),matRampGlow);
      eg.position.set(rd.x+(isZ?s*rWid/2:0), LVL_H/2, rd.z+(isZ?0:s*rWid/2));
      if(isZ) eg.rotation.x=rM.rotation.x; else eg.rotation.z=rM.rotation.z;
      arenaGrp.add(eg);
    }
    // Chevron arrows pointing UP the ramp (toward the platform)
    // "Up" direction is: -dz for Z-ramps, -dx for X-ramps (toward platform center)
    const arrowMat=new THREE.MeshStandardMaterial({color:0x00ffff,emissive:0x00ffff,emissiveIntensity:1.2,transparent:true,opacity:0.9});
    const arrowMatDim=new THREE.MeshStandardMaterial({color:0x0088cc,emissive:0x0088cc,emissiveIntensity:0.6,transparent:true,opacity:0.6});
    for(let i=0;i<5;i++){
      const frac=(i+1)/6;
      const ry=frac*LVL_H;
      const mat=(i%2===0)?arrowMat:arrowMatDim;
      // Build a chevron: two angled bars forming a "V" pointing up-ramp
      const chevW=2.0, chevD=0.8, barT=0.18;
      for(let s=-1;s<=1;s+=2){
        const bar=new THREE.Mesh(new THREE.BoxGeometry(isZ?chevW*0.55:barT, barT, isZ?barT:chevW*0.55),mat);
        if(isZ){
          // Z-ramp: chevron points along -dz (toward platform)
          bar.position.set(rd.x+s*chevW*0.28, ry+0.15, rd.z+rd.dz*(rLen/2-frac*rLen));
          bar.rotation.y=s*0.45*(-rd.dz); // angle the bars into a V
        } else {
          // X-ramp: chevron points along -dx (toward platform)
          bar.position.set(rd.x+rd.dx*(rLen/2-frac*rLen), ry+0.15, rd.z+s*chevW*0.28);
          bar.rotation.y=s*0.45*(rd.dx); // angle into V
        }
        arenaGrp.add(bar);
      }
      // Center dot/dash for extra visibility
      const dot=new THREE.Mesh(new THREE.BoxGeometry(isZ?0.4:0.12, 0.12, isZ?0.12:0.4),mat);
      if(isZ) dot.position.set(rd.x, ry+0.15, rd.z+rd.dz*(rLen/2-frac*rLen)-rd.dz*chevD*0.5);
      else dot.position.set(rd.x+rd.dx*(rLen/2-frac*rLen)-rd.dx*chevD*0.5, ry+0.15, rd.z);
      arenaGrp.add(dot);
    }
    // Tall glowing side pillars at ramp base and top for landmark visibility
    const pillarH=4, pillarR=0.2;
    const pillarMat=new THREE.MeshStandardMaterial({color:0x00ccff,emissive:0x00ccff,emissiveIntensity:0.9,transparent:true,opacity:0.7});
    const pillarGeo=new THREE.CylinderGeometry(pillarR,pillarR,pillarH,6);
    for(let s=-1;s<=1;s+=2){
      // Bottom of ramp
      const pb=new THREE.Mesh(pillarGeo,pillarMat);
      if(isZ) pb.position.set(rd.x+s*(rWid/2+0.5), pillarH/2, rd.z+rd.dz*rLen/2);
      else pb.position.set(rd.x+rd.dx*rLen/2, pillarH/2, rd.z+s*(rWid/2+0.5));
      arenaGrp.add(pb);
      // Top of ramp
      const pt=new THREE.Mesh(pillarGeo,pillarMat);
      if(isZ) pt.position.set(rd.x+s*(rWid/2+0.5), LVL_H+pillarH/2, rd.z-rd.dz*rLen/2);
      else pt.position.set(rd.x-rd.dx*rLen/2, LVL_H+pillarH/2, rd.z+s*(rWid/2+0.5));
      arenaGrp.add(pt);
    }
    // Collision zone
    rampZones.push({
      x:rd.x, z:rd.z, dx:rd.dx, dz:rd.dz,
      halfW:isZ?rWid/2:rLen/2, halfD:isZ?rLen/2:rWid/2,
      contains(px,pz){return Math.abs(px-this.x)<this.halfW && Math.abs(pz-this.z)<this.halfD},
      getY(px,pz){
        let t;
        if(isZ){
          const bottom=this.z+rd.dz*this.halfD;
          const top=this.z-rd.dz*this.halfD;
          t=(pz-bottom)/(top-bottom);
        } else {
          const bottom=this.x+rd.dx*this.halfW;
          const top=this.x-rd.dx*this.halfW;
          t=(px-bottom)/(top-bottom);
        }
        return Math.max(0,Math.min(LVL_H,t*LVL_H));
      }
    });
  });
}

// FIX: Build arena immediately so title screen has something to render behind overlay
buildArena();

// Level-aware height function: currentGy is the rider's current height.
// Riders can ONLY change levels by physically riding onto a ramp.
// If on the lower level and under the upper platform, stay at 0.
// If on a ramp, follow the ramp slope.
// If on the upper platform (already up there), stay at LVL_H.
function getY(px, pz, currentGy){
  // First check ramps â€” ramps always apply regardless of current level
  for(const r of rampZones){
    if(r.contains(px,pz)) return r.getY(px,pz);
  }
  // If already on the upper level (came via ramp), and within platform bounds, stay up
  if(currentGy > LVL_H*0.3 && upperBounds &&
     px>upperBounds.x1 && px<upperBounds.x2 &&
     pz>upperBounds.z1 && pz<upperBounds.z2){
    return LVL_H;
  }
  // Otherwise stay on the lower level â€” even if under the platform footprint
  return 0;
}

// ============================================================
//  LIGHT CYCLE â€” motorcycle from blueprint
// ============================================================
function buildCycle(col){
  const g=new THREE.Group();
  const gc=new THREE.Color(col);
  const dk=new THREE.MeshStandardMaterial({color:0x080810,emissive:gc,emissiveIntensity:0.03,roughness:0.3,metalness:0.9});
  const gl=new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:1.2,roughness:0.1});
  const gd=new THREE.MeshStandardMaterial({color:col,emissive:col,emissiveIntensity:0.5});

  const WR=0.7, WT=0.14, BW=0.6;

  // Rear wheel
  const rw=new THREE.Mesh(new THREE.TorusGeometry(WR,WT,10,28),gl);
  rw.rotation.y=Math.PI/2; rw.position.set(0,WR,-1.9); g.add(rw);
  const rwf=new THREE.Mesh(new THREE.CylinderGeometry(WR-0.03,WR-0.03,0.2,28),dk);
  rwf.rotation.z=Math.PI/2; rwf.position.set(0,WR,-1.9); g.add(rwf);

  // Front wheel
  const fw=new THREE.Mesh(new THREE.TorusGeometry(WR,WT,10,28),gl);
  fw.rotation.y=Math.PI/2; fw.position.set(0,WR,2.1); g.add(fw);
  const fwf=new THREE.Mesh(new THREE.CylinderGeometry(WR-0.03,WR-0.03,0.2,28),dk);
  fwf.rotation.z=Math.PI/2; fwf.position.set(0,WR,2.1); g.add(fwf);

  // Chassis (wide extruded profile)
  const cs=new THREE.Shape();
  cs.moveTo(2.4,0.5);
  cs.quadraticCurveTo(1.6,0.9,0.8,1.05);
  cs.quadraticCurveTo(0,1.12,-0.4,1.0);
  cs.quadraticCurveTo(-1.0,0.8,-1.6,0.55);
  cs.lineTo(-1.9,0.45);
  cs.lineTo(-1.9,0.25);
  cs.quadraticCurveTo(-0.5,0.12,0.5,0.12);
  cs.quadraticCurveTo(1.5,0.18,2.2,0.35);
  cs.lineTo(2.4,0.5);

  const cGeo=new THREE.ExtrudeGeometry(cs,{steps:1,depth:BW,bevelEnabled:true,bevelThickness:0.06,bevelSize:0.06,bevelSegments:2});
  cGeo.translate(0,0,-BW/2);
  const cM=new THREE.Mesh(cGeo,dk);
  cM.rotation.y=Math.PI/2;
  g.add(cM);

  // Rider
  const torso=new THREE.Mesh(new THREE.BoxGeometry(0.55,0.5,0.55),dk);
  torso.position.set(0,1.35,0.1); torso.rotation.x=0.4; g.add(torso);
  const head=new THREE.Mesh(new THREE.SphereGeometry(0.19,8,6),dk);
  head.position.set(0,1.65,0.5); g.add(head);
  // Visor
  const visor=new THREE.Mesh(new THREE.BoxGeometry(0.36,0.07,0.1),gl);
  visor.position.set(0,1.63,0.68); g.add(visor);

  for(let s=-1;s<=1;s+=2){
    const arm=new THREE.Mesh(new THREE.CylinderGeometry(0.06,0.05,0.55,6),dk);
    arm.position.set(s*0.33,1.15,0.6); arm.rotation.x=1.1; g.add(arm);
    // Arm glow strips
    const ag1=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.5),gl);
    ag1.position.set(s*0.33,1.17,0.6); ag1.rotation.set(1.1,0,0); g.add(ag1);
    const ag2=new THREE.Mesh(new THREE.BoxGeometry(0.04,0.04,0.55),gl);
    ag2.position.set(s*0.16,1.35,0.1); ag2.rotation.set(0.4,0,0); g.add(ag2);
  }

  // Flowing glow curves
  function mkC(xo){
    const pts=[
      new THREE.Vector3(xo, 0.45, 2.4),
      new THREE.Vector3(xo*1.15, 0.6, 1.4),
      new THREE.Vector3(xo*1.25, 0.9, 0.4),
      new THREE.Vector3(xo*1.2, 1.05, -0.2),
      new THREE.Vector3(xo*1.1, 0.85, -1.0),
      new THREE.Vector3(xo, 0.6, -1.7),
      new THREE.Vector3(xo*0.9, 0.48, -2.2)
    ];
    return new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts),24,0.03,6,false),gl);
  }
  g.add(mkC(-0.35)); g.add(mkC(0.35));

  function mkC2(xo){
    const pts=[
      new THREE.Vector3(xo, 0.55, 1.8),
      new THREE.Vector3(xo*1.1, 0.75, 0.6),
      new THREE.Vector3(xo*1.15, 0.95, -0.1),
      new THREE.Vector3(xo*1.05, 0.78, -0.9),
      new THREE.Vector3(xo, 0.55, -1.7)
    ];
    return new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(pts),16,0.02,5,false),gd);
  }
  g.add(mkC2(-0.22)); g.add(mkC2(0.22));

  // Spine
  const sp=[
    new THREE.Vector3(0,1.08,-1.5),
    new THREE.Vector3(0,1.14,-0.2),
    new THREE.Vector3(0,1.15,0.5),
    new THREE.Vector3(0,0.92,1.3)
  ];
  g.add(new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(sp),10,0.025,5,false),gl));

  // Engine block
  const eng=new THREE.Mesh(new THREE.BoxGeometry(0.5,0.3,0.7),dk);
  eng.position.set(0,0.35,0); g.add(eng);
  // Engine vents
  const ventMat=new THREE.MeshStandardMaterial({color:0xaaaa00,emissive:0xaaaa00,emissiveIntensity:0.7});
  for(let i=0;i<3;i++){
    const vent=new THREE.Mesh(new THREE.BoxGeometry(0.52,0.025,0.05),ventMat);
    vent.position.set(0, 0.25+i*0.09, -0.22+i*0.14);
    g.add(vent);
  }

  // Exhaust
  const exh=new THREE.Mesh(new THREE.BoxGeometry(0.4,0.2,0.05),gl);
  exh.position.set(0,0.5,-2.25); g.add(exh);
  // Headlight
  const hl=new THREE.Mesh(new THREE.SphereGeometry(0.08,8,6),gl);
  hl.position.set(0,0.72,2.55); g.add(hl);
  // Underglow
  const ugm=new THREE.MeshBasicMaterial({color:col,transparent:true,opacity:0.1,side:THREE.DoubleSide});
  const ug=new THREE.Mesh(new THREE.PlaneGeometry(0.7,4.8),ugm);
  ug.rotation.x=-Math.PI/2; ug.position.set(0,0.02,0); g.add(ug);

  return g;
}

// ============================================================
//  TRAILS â€” spatial grid for fast collision
// ============================================================
const TRAIL_H=2.2;
const GRID_SIZE=2;
let trailGrid={};

function trailKey(x,z){return Math.floor(x/GRID_SIZE)+'_'+Math.floor(z/GRID_SIZE)}

function addTrail(r){
  const mat=new THREE.MeshBasicMaterial({color:r.color,transparent:true,opacity:0.75,side:THREE.DoubleSide});
  const geo=new THREE.PlaneGeometry(0.8,TRAIL_H);
  const m=new THREE.Mesh(geo,mat);
  const gy=r.gy||0;
  m.position.set(r.x, gy+TRAIL_H/2+0.05, r.z);
  m.rotation.y=r.angle+Math.PI/2;
  scene.add(m);
  const seg={x:r.x, z:r.z, y:gy, mesh:m, oid:r.id, age:0};
  r.trail.push(seg);
  trailSegs.push(seg);
  const k=trailKey(r.x,r.z);
  if(!trailGrid[k]) trailGrid[k]=[];
  trailGrid[k].push(seg);
}

function hitTrail(px,pz,py,oid){
  const cx=Math.floor(px/GRID_SIZE), cz=Math.floor(pz/GRID_SIZE);
  for(let dx=-1;dx<=1;dx++){
    for(let dz=-1;dz<=1;dz++){
      const k=(cx+dx)+'_'+(cz+dz);
      const cell=trailGrid[k];
      if(!cell) continue;
      for(const s of cell){
        if(s.oid===oid && s.age<0.6) continue;
        if(Math.abs(s.y-py)>TRAIL_H) continue;
        if(Math.hypot(px-s.x,pz-s.z)<1.3) return true;
      }
    }
  }
  return false;
}

// ============================================================
//  RIDERS
// ============================================================
let nextId=0;
const P_COL=0x00ffcc, E_COLS=[0xff2200,0xff4400,0xff0044,0xcc4400,0xaa0000];

function mkRider(isP,col,x,z,a){
  const mesh=buildCycle(col);
  mesh.position.set(x,0,z);
  mesh.rotation.y=a;
  scene.add(mesh);
  const light=new THREE.PointLight(col,1.5,20);
  light.position.set(x,2.5,z);
  scene.add(light);
  return{id:nextId++, isP, color:col, mesh, light, x, z, angle:a, speed:MIN_SPEED, gy:0, alive:true, trail:[], tt:0, aiTurn:0, aiNext:0};
}

function killRider(r){
  if(!r.alive) return;
  r.alive=false;
  scene.remove(r.mesh);
  scene.remove(r.light);
  r.trail.forEach(s=>{if(s.mesh && s.mesh.material) s.mesh.material.opacity=0.3});
  addMsg(r.isP?'DEREZZED':'OPPONENT ELIMINATED');
  if(!r.isP) score+=100;
}

// ============================================================
//  AI
// ============================================================
function aiUpdate(r,dt){
  if(!r.alive||r.isP) return;
  r.aiTurn-=dt;
  r.aiNext-=dt;
  r.speed+=(MIN_SPEED*1.1-r.speed)*2*dt;

  const look=r.speed*0.4+5;
  const ax=r.x+Math.sin(r.angle)*look, az=r.z+Math.cos(r.angle)*look;
  const gy=r.gy;
  let danger=ax<4||ax>AX-4||az<4||az>AZ-4;
  if(!danger) danger=hitTrail(ax,az,gy,r.id);
  if(!danger){
    const ax2=r.x+Math.sin(r.angle)*look*0.4;
    const az2=r.z+Math.cos(r.angle)*look*0.4;
    danger=hitTrail(ax2,az2,gy,r.id);
  }

  if(danger && r.aiTurn<=0){
    const ta=Math.PI/2;
    const lx=r.x+Math.sin(r.angle+ta)*look, lz=r.z+Math.cos(r.angle+ta)*look;
    const rx=r.x+Math.sin(r.angle-ta)*look, rz=r.z+Math.cos(r.angle-ta)*look;
    const lOk=!hitTrail(lx,lz,gy,r.id)&&lx>3&&lx<AX-3&&lz>3&&lz<AZ-3;
    const rOk=!hitTrail(rx,rz,gy,r.id)&&rx>3&&rx<AX-3&&rz>3&&rz<AZ-3;
    if(lOk&&!rOk) r.angle+=ta;
    else if(rOk&&!lOk) r.angle-=ta;
    else r.angle+=(Math.random()>0.5?1:-1)*ta;
    r.aiTurn=0.35+Math.random()*0.25;
  }
  if(r.aiNext<=0){
    r.aiNext=2+Math.random()*3;
    if(Math.random()<0.3 && r.aiTurn<=0){
      r.angle+=(Math.random()>0.5?1:-1)*Math.PI/2;
      r.aiTurn=0.4;
    }
  }
}

// ============================================================
//  INPUT â€” Touch, Keyboard, and Gamepad (Backbone One)
// ============================================================

// --- GAMEPAD STATE ---
let gpConnected=false, gpIndex=-1;
let gpButtonsLast=new Array(20).fill(false); // for edge detection

// Standard Gamepad mapping (Backbone One is MFi/standard):
// axes[0]=left stick X, axes[1]=left stick Y
// axes[2]=right stick X, axes[3]=right stick Y
// buttons[0]=A(bottom), 1=B(right), 2=X(left), 3=Y(top)
// buttons[4]=LB, 5=RB, 6=LT, 7=RT
// buttons[8]=Back/Select, 9=Start/Menu
// buttons[12]=DPad Up, 13=DPad Down, 14=DPad Left, 15=DPad Right

window.addEventListener('gamepadconnected', e=>{
  gpIndex=e.gamepad.index;
  gpConnected=true;
  document.body.classList.add('gp-mode');
  document.getElementById('gp-status').textContent='ðŸŽ® '+e.gamepad.id.substring(0,30);
  addMsg('GAMEPAD CONNECTED');
  onResize(); // recalculate since controls panel is now hidden
});
window.addEventListener('gamepaddisconnected', e=>{
  if(e.gamepad.index===gpIndex){
    gpConnected=false; gpIndex=-1;
    document.body.classList.remove('gp-mode');
    document.getElementById('gp-status').textContent='';
    addMsg('GAMEPAD DISCONNECTED');
    onResize();
  }
});

function getGamepad(){
  if(!gpConnected||!navigator.getGamepads) return null;
  const gps=navigator.getGamepads();
  return gps[gpIndex]||null;
}

// Returns true on the frame a button transitions from releasedâ†’pressed
function gpButtonPressed(btnIndex){
  const gp=getGamepad();
  if(!gp||!gp.buttons[btnIndex]) return false;
  const pressed=gp.buttons[btnIndex].pressed;
  const wasPressed=gpButtonsLast[btnIndex];
  return pressed&&!wasPressed;
}

// Poll gamepad buttons for menu navigation (called each frame)
function gpPollMenus(){
  const gp=getGamepad();
  if(!gp) return;
  // A button (0) or Start (9) to advance through menus
  if(gpButtonPressed(0)||gpButtonPressed(9)){
    if(state==='title') startGame();
    else if(state==='roundStart') startRound();
    else if(state==='win') nextRound();
    else if(state==='dead') retry();
  }
  // Update last-frame button states for edge detection
  for(let i=0;i<gp.buttons.length&&i<gpButtonsLast.length;i++){
    gpButtonsLast[i]=gp.buttons[i].pressed;
  }
}

// --- TOUCH STICKS ---
function mkStick(zId,kId){
  const z=document.getElementById(zId), k=document.getElementById(kId);
  const s={x:0,y:0,tid:null,md:false};
  function calc(cx,cy,clx,cly){
    let dx=clx-cx, dy=cly-cy;
    const mr=z.clientWidth/2-10;
    const d=Math.hypot(dx,dy);
    if(d>mr){dx=dx/d*mr; dy=dy/d*mr}
    s.x=dx/mr; s.y=dy/mr;
    k.style.transform=`translate(calc(-50% + ${dx}px),calc(-50% + ${dy}px))`;
  }
  function rst(){s.x=0;s.y=0;s.tid=null;s.md=false;k.style.transform='translate(-50%,-50%)';k.classList.remove('active')}
  z.addEventListener('touchstart',e=>{e.preventDefault();s.tid=e.changedTouches[0].identifier;k.classList.add('active')},{passive:false});
  z.addEventListener('touchmove',e=>{e.preventDefault();for(const t of e.changedTouches)if(t.identifier===s.tid){const r=z.getBoundingClientRect();calc(r.left+r.width/2,r.top+r.height/2,t.clientX,t.clientY)}},{passive:false});
  z.addEventListener('touchend',e=>{for(const t of e.changedTouches)if(t.identifier===s.tid)rst()});
  z.addEventListener('touchcancel',e=>{for(const t of e.changedTouches)if(t.identifier===s.tid)rst()});
  z.addEventListener('mousedown',e=>{e.preventDefault();s.md=true;k.classList.add('active')});
  window.addEventListener('mousemove',e=>{if(!s.md)return;const r=z.getBoundingClientRect();calc(r.left+r.width/2,r.top+r.height/2,e.clientX,e.clientY)});
  window.addEventListener('mouseup',()=>{if(s.md)rst()});
  return s;
}
const steerS=mkStick('sz-steer','sk-steer'), thrS=mkStick('sz-thr','sk-thr');
document.addEventListener('touchmove',e=>e.preventDefault(),{passive:false});

// --- KEYBOARD ---
let keys={};
window.addEventListener('keydown',e=>{keys[e.code]=true});
window.addEventListener('keyup',e=>{keys[e.code]=false});

// --- UNIFIED INPUT ---
function inp(){
  let st=0, th=0;

  // Keyboard
  if(keys['KeyA']||keys['ArrowLeft']) st=-1;
  if(keys['KeyD']||keys['ArrowRight']) st=1;
  if(keys['KeyW']||keys['ArrowUp']) th=1;
  if(keys['KeyS']||keys['ArrowDown']) th=-0.5;
  if(keys['Space']) th=1.5;

  // Touch sticks
  if(Math.abs(steerS.x)>0.1) st+=steerS.x;
  if(Math.abs(thrS.y)>0.1) th-=thrS.y;

  // Gamepad (Backbone One / standard mapping)
  const gp=getGamepad();
  if(gp){
    // Left stick X for steering (with deadzone)
    const lsX=gp.axes[0]||0;
    if(Math.abs(lsX)>0.12) st+=lsX;

    // Right trigger (button 7) = gas, value 0-1
    const rt=gp.buttons[7]?gp.buttons[7].value:0;
    // Left trigger (button 6) = brake
    const lt=gp.buttons[6]?gp.buttons[6].value:0;

    if(rt>0.1) th+=rt;        // gas: 0â†’1
    if(lt>0.1) th-=lt*0.5;    // brake

    // A button (0) = boost
    if(gp.buttons[0]&&gp.buttons[0].pressed) th=1.5;

    // B button (1) = brake hard
    if(gp.buttons[1]&&gp.buttons[1].pressed) th=-0.5;

    // Left stick Y for forward/back as alternative
    const lsY=gp.axes[1]||0;
    if(Math.abs(lsY)>0.2&&rt<0.1&&lt<0.1){
      th-=lsY*0.8; // push forward = -Y = positive throttle
    }
  }

  return{st:Math.max(-1,Math.min(1,st)), th:Math.max(-0.5,Math.min(1.5,th))};
}

// ============================================================
//  UPDATE
// ============================================================
function update(dt){
  if(state!=='playing') return;
  gt+=dt;
  const i=inp();

  riders.forEach(r=>{
    if(!r.alive) return;

    if(r.isP){
      r.angle-=i.st*3.2*dt;
      const target=i.th>1?BOOST_SPEED:(i.th>0.1?MAX_SPEED:(i.th<-0.1?MIN_SPEED*0.5:MIN_SPEED));
      r.speed+=(target-r.speed)*4*dt;
      if(r.speed<MIN_SPEED*0.4) r.speed+=12*dt;
    } else {
      aiUpdate(r,dt);
    }

    const nx=r.x+Math.sin(r.angle)*r.speed*dt;
    const nz=r.z+Math.cos(r.angle)*r.speed*dt;

    // Wall collision
    if(nx<1||nx>AX-1||nz<1||nz>AZ-1){killRider(r);return}

    // Upper platform edge collision
    if(r.gy>=LVL_H-0.5 && upperBounds){
      const onRamp=rampZones.some(rz=>rz.contains(nx,nz));
      const onUpper=nx>upperBounds.x1&&nx<upperBounds.x2&&nz>upperBounds.z1&&nz<upperBounds.z2;
      if(!onUpper&&!onRamp){killRider(r);return}
    }

    r.x=nx; r.z=nz;
    r.gy=getY(r.x, r.z, r.gy);

    // Trail collision
    if(hitTrail(r.x,r.z,r.gy,r.id)){killRider(r);return}

    // Lay trail
    r.tt+=dt;
    if(r.speed>3 && r.tt>0.04){r.tt=0;addTrail(r)}

    r.mesh.position.set(r.x,r.gy,r.z);
    r.mesh.rotation.y=r.angle;
    if(r.isP) r.mesh.rotation.z=i.st*0.15;
    r.light.position.set(r.x,r.gy+2.5,r.z);
  });

  // Age trails
  for(let j=trailSegs.length-1;j>=0;j--){
    trailSegs[j].age+=dt;
  }

  // Camera follow â€” wider pulled-back view
  if(player && player.alive){
    const cd=14, ch=8;  // increased from 8/5 for wider field
    const idealX=player.x-Math.sin(player.angle)*cd;
    const idealZ=player.z-Math.cos(player.angle)*cd;
    const idealPos=new THREE.Vector3(idealX, player.gy+ch, idealZ);
    const lookTarget=new THREE.Vector3(
      player.x+Math.sin(player.angle)*14,
      player.gy+1.0,
      player.z+Math.cos(player.angle)*14
    );
    // FIX: faster lerp so camera doesn't lag behind for ages
    camera.position.lerp(idealPos, 0.12);
    camera.lookAt(lookTarget);
  }

  // Win/lose check
  const aliveE=riders.filter(r=>r.alive&&!r.isP).length;
  if(player && !player.alive && state==='playing'){
    state='dead';
    setTimeout(()=>{
      document.getElementById('scr-dead').classList.remove('hidden');
      document.getElementById('dead-info').textContent='ROUND '+round+' â€” SCORE '+score;
    },800);
  } else if(aliveE===0 && player && player.alive && state==='playing'){
    wins++; score+=round*200; state='win';
    setTimeout(()=>{
      document.getElementById('scr-win').classList.remove('hidden');
      document.getElementById('win-info').textContent='ROUND '+round+' CLEAR â€” SCORE '+score;
    },600);
  }

  updHUD();
  // FIX: guard against dead player
  if(player && player.alive){
    const spd=Math.floor(player.speed*10);
    const boostPct=Math.min(100,player.speed/MAX_SPEED*100)+'%';
    const floorTxt=player.gy>LVL_H*0.4?'UPPER LEVEL':'LOWER LEVEL';
    // Touch controls HUD
    document.getElementById('speed-display').textContent=spd;
    document.getElementById('boost-bar').style.width=boostPct;
    document.getElementById('floor-ind').textContent=floorTxt;
    // Gamepad in-viewport HUD
    document.getElementById('gp-speed').textContent=spd;
    document.getElementById('gp-boost-bar').style.width=boostPct;
    document.getElementById('gp-floor').textContent=floorTxt;
  }
}

function updHUD(){
  document.getElementById('alive-val').textContent=riders.filter(r=>r.alive&&!r.isP).length;
  document.getElementById('round-val').textContent=round;
  document.getElementById('wins-val').textContent=wins;
  document.getElementById('score-val').textContent=score;
}

function addMsg(t){
  const el=document.createElement('div');
  el.className='message'; el.textContent=t;
  document.getElementById('messages').appendChild(el);
  setTimeout(()=>el.remove(),3000);
}

function drawMM(){
  mmX.fillStyle='#000a18'; mmX.fillRect(0,0,150,150);
  const s=150/AX;
  if(upperBounds){
    mmX.strokeStyle='#0af3';mmX.lineWidth=1;
    mmX.strokeRect(upperBounds.x1*s, upperBounds.z1*s, (upperBounds.x2-upperBounds.x1)*s, (upperBounds.z2-upperBounds.z1)*s);
  }
  mmX.fillStyle='#0af2';
  rampZones.forEach(r=>{mmX.fillRect((r.x-r.halfW)*s,(r.z-r.halfD)*s,r.halfW*2*s,r.halfD*2*s)});
  mmX.strokeStyle='#0664'; mmX.strokeRect(0,0,AX*s,AZ*s);
  trailSegs.forEach(seg=>{
    const owner=riders.find(r=>r.id===seg.oid);
    mmX.fillStyle=owner&&owner.isP?'#0fc4':'#f224';
    mmX.fillRect(seg.x*s,seg.z*s,1.2,1.2);
  });
  riders.forEach(r=>{
    if(!r.alive)return;
    mmX.fillStyle=r.isP?'#0ff':'#f22';
    mmX.beginPath();mmX.arc(r.x*s,r.z*s,3,0,Math.PI*2);mmX.fill();
    mmX.strokeStyle=mmX.fillStyle;mmX.lineWidth=1.5;
    mmX.beginPath();mmX.moveTo(r.x*s,r.z*s);
    mmX.lineTo(r.x*s+Math.sin(r.angle)*8,r.z*s+Math.cos(r.angle)*8);mmX.stroke();
  });
}

// ============================================================
//  INIT ROUND
// ============================================================
function initRound(){
  // Clean up previous round
  riders.forEach(r=>{scene.remove(r.mesh);scene.remove(r.light)});
  trailSegs.forEach(s=>{
    scene.remove(s.mesh);
    if(s.mesh.geometry) s.mesh.geometry.dispose();
    if(s.mesh.material) s.mesh.material.dispose();
  });
  riders=[]; trailSegs=[]; trailGrid={}; gt=0; nextId=0;

  buildArena();

  const cx=AX/2, cz=AZ/2, sr=50;
  player=mkRider(true, P_COL, cx, cz+sr, 0);
  riders.push(player);

  const ne=Math.min(1+round, 5);
  for(let i=0;i<ne;i++){
    const a=(i/ne)*Math.PI*2+Math.PI;
    riders.push(mkRider(false, E_COLS[i%E_COLS.length], cx+Math.cos(a)*sr, cz+Math.sin(a)*sr, a+Math.PI));
  }

  // Snap camera to player position immediately
  const cd=14, ch=8;
  camera.position.set(
    player.x - Math.sin(player.angle)*cd,
    player.gy + ch,
    player.z - Math.cos(player.angle)*cd
  );
  camera.lookAt(
    player.x + Math.sin(player.angle)*14,
    player.gy + 1.0,
    player.z + Math.cos(player.angle)*14
  );
}

// ============================================================
//  GAME FLOW
// ============================================================
function showScreen(id){
  document.querySelectorAll('.overlay').forEach(e=>e.classList.add('hidden'));
  if(id) document.getElementById(id).classList.remove('hidden');
}

function startGame(){
  round=1; wins=0; score=0;
  state='roundStart';  // FIX: set state so keyboard shortcuts work
  showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND 1';
  document.getElementById('round-sub').textContent='2 OPPONENTS';
}

function startRound(){
  showScreen(null);
  initRound();  // FIX: init round BEFORE setting state to playing
  state='playing';
}

function nextRound(){
  round++;
  state='roundStart';  // FIX: set state
  showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND '+round;
  document.getElementById('round-sub').textContent=Math.min(1+round,5)+' OPPONENTS';
}

function retry(){
  round=1; wins=0; score=0;
  state='roundStart';  // FIX: set state
  showScreen('scr-round');
  document.getElementById('round-title').textContent='ROUND 1';
  document.getElementById('round-sub').textContent='2 OPPONENTS';
}

document.getElementById('btn-start').addEventListener('click',e=>{e.preventDefault();startGame()});
document.getElementById('btn-round').addEventListener('click',e=>{e.preventDefault();startRound()});
document.getElementById('btn-next').addEventListener('click',e=>{e.preventDefault();nextRound()});
document.getElementById('btn-retry').addEventListener('click',e=>{e.preventDefault();retry()});

window.addEventListener('keydown',e=>{
  if(e.code==='Enter'){
    e.preventDefault();
    if(state==='title') startGame();
    else if(state==='roundStart') startRound();
    else if(state==='win') nextRound();
    else if(state==='dead') retry();
  }
});

// ============================================================
//  RENDER LOOP
// ============================================================
let lastT=0;
function loop(t){
  requestAnimationFrame(loop);
  const dt=Math.min(0.05,(t-lastT)/1000);
  lastT=t;

  // Poll gamepad for menu navigation (runs every frame regardless of state)
  gpPollMenus();

  if(state==='playing'){
    update(dt);
  } else {
    // Orbit camera around arena during menus so the grid is visible behind overlays
    const now=performance.now()*0.0003;
    const cx=AX/2, cz=AZ/2, orbitR=130;
    camera.position.set(cx+Math.cos(now)*orbitR, 60, cz+Math.sin(now)*orbitR);
    camera.lookAt(cx, 4, cz);
  }

  renderer.render(scene,camera);

  if(state==='playing') drawMM();
}
requestAnimationFrame(loop);
</script>
</body></html>
